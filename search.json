[
  {
    "objectID": "doc/tp/tp2.html",
    "href": "doc/tp/tp2.html",
    "title": "Webservices et formats de données",
    "section": "",
    "text": "😱 Comme vous pouvez le constater, le sujet de ce TP est lui aussi long. Cela ne doit pas vous effrayer. Il mélange explications complètes et manipulations pour être au maximum autosuffisant. Vous n’allez surement pas terminer le sujet, ce n’est pas grave. Il est là pour vous aider lors du projet informatique.\n❗ Il est possible que les copier-coller fonctionnent étrangement (caractère de fin de ligne qui disparaissent, indentation qui change). Faites-y attention !\nCe TP mêle explications pour vous faire comprendre ce qui est fait, et phases de manipulation ou code. Ces phases sont appelées “✍️Hands on”. C’est à ce moment là que vous devez faire ce qui est écrit dans le TP. Les explications de ce TP ne doivent pas prendre le pas sur celles de votre intervenant. Prenez les comme une base de connaissances pour plus tard, mais préférez toujours les explications orales, surtout pour poser des questions.\n\nDans ce TP vous allez :\n\nFaire des appels à un webservice à la main avec Insomnia\nFaire des appels à un webservice avec la bibliothèque python requests\nDécouvrir la page swagger d’un webservice\nManipuler différents formats de données\nCréer un webservice avec le framework python fastAPI"
  },
  {
    "objectID": "doc/tp/tp2.html#avant-de-commencer",
    "href": "doc/tp/tp2.html#avant-de-commencer",
    "title": "Webservices et formats de données",
    "section": "",
    "text": "😱 Comme vous pouvez le constater, le sujet de ce TP est lui aussi long. Cela ne doit pas vous effrayer. Il mélange explications complètes et manipulations pour être au maximum autosuffisant. Vous n’allez surement pas terminer le sujet, ce n’est pas grave. Il est là pour vous aider lors du projet informatique.\n❗ Il est possible que les copier-coller fonctionnent étrangement (caractère de fin de ligne qui disparaissent, indentation qui change). Faites-y attention !\nCe TP mêle explications pour vous faire comprendre ce qui est fait, et phases de manipulation ou code. Ces phases sont appelées “✍️Hands on”. C’est à ce moment là que vous devez faire ce qui est écrit dans le TP. Les explications de ce TP ne doivent pas prendre le pas sur celles de votre intervenant. Prenez les comme une base de connaissances pour plus tard, mais préférez toujours les explications orales, surtout pour poser des questions.\n\nDans ce TP vous allez :\n\nFaire des appels à un webservice à la main avec Insomnia\nFaire des appels à un webservice avec la bibliothèque python requests\nDécouvrir la page swagger d’un webservice\nManipuler différents formats de données\nCréer un webservice avec le framework python fastAPI"
  },
  {
    "objectID": "doc/tp/tp2.html#appeler-un-webservice-à-la-main",
    "href": "doc/tp/tp2.html#appeler-un-webservice-à-la-main",
    "title": "Webservices et formats de données",
    "section": "1 Appeler un webservice à la main",
    "text": "1 Appeler un webservice à la main\nLa première partie de ce TP ne nécessite pas d’écrire du code, mais seulement de faire des requêtes à un webservice en utilisant Insomnia.\n\n1.1 Webservices\n\n📖 Webservice : le terme webservice est un terme vaste et il serait compliqué d’en donner une définition courte (article wikipedia). Dans le cadre du projet un webservice désigne une application accessible via le protocole HTTP (HyperText Transfer Protocol) qui respecte généralement l’architecture REST (* REpresentational State Transfer). Mais il en existe d’autre comme SOAP (Simple Objet* Access Protocol) ou RPC (Remote Procedure Call)\n\nEn d’autres termes, un webservice est une application accessible via le web que l’on va pouvoir requêter soit pour obtenir des ressources, soit pour modifier les ressources accessibles. Un webservice peut seulement avoir pour but d’être une point d’accès unique et normalisé à des données (comme une interface à une base de données), mais il peut également être une manière de contrôler un système d’information (lancer des travaux, les mettre en attente, récupérer des résultats, etc)\nLes webservices utilisent le protocole HTTP qui est le protocole du web (et pas d’internet). C’est celui que vous utilisez sans le savoir avec votre navigateur web. Requêter un webservice se fait presque comme requêter une page web. Pour cela il vous faut l’adresse de la ressource, son Uniforme Resource Identifier, ou URI (c’est une notion plus générale que les Uniforme Resource Locator, ou URL), une méthode (GET, POST, PUT, DELETE, liste des méthodes), et potentiellement des données.\n\n\n1.2 Découverte d’Insomnia et premières requêtes GET\n✍️Hands on 1\n\nLancez le programme Insomnia (recherchez dans le menu démarrer)\nCréez une collection de requête\n\nbouton Create à droite\npuis cliquez sur votre collection\n\nCréez une nouvelle requête\n\nen appuyant sur CTRL+N\ndonnez lui un nom\nvérifiez que c’est bien une requête de type GET\n\nDans la barre d’adresse, testez les requêtes ci-dessous\n\nRegardez la réponse dans la partie droite de votre écran.\nQuelles sont les similarités entre les réponses ?\n\n\nRequêtes à tester :\n\nWebservice sur les émissions carbone du Royaume-Uni :\n\napi.carbonintensity.org.uk/intensity\napi.carbonintensity.org.uk/intensity/date/{date}\n\nen remplaçant {date} par la date de votre choix au format YYYY-MM-DD\n\n\nWebservice pour obtenir différents jeux de données ouverts de la ville de Rennes\n\ndata.rennesmetropole.fr/api/records/1.0/search?dataset=menus-cantines\nTestez différentes valeurs pour dataset :eco-counter-data, rva-bal, resultats-des-elections-municipales-2020-a-acigne\nAjouter à la fin de l’URI le paramètre rows\n\npour faire varier le nombre de lignes que vous recevez\najouter simplement &rows=X avec X le nombre de lignes\n\n\nQuelques méthodes du webservice utiles pour votre projet informatique (voyez cela avec votre tuteur)\n\n\n\n\n1.3 Requêtes avancées\n✍️Hands on 2 (toujours avec Insomnia)\n\nFaites une requête avec la méthode GET sur la ressource suivante. Qu’obtenez-vous ?\n\nweb-services.domensai.ecole/attack\n\nFaites une requête avec la méthode GET sur la ressource suivante. Qu’obtenez-vous ?\n\nweb-services.domensai.ecole/attack/{identifier}\nen remplaçant {identifier} par le nom ou l’id d’une attaque que vous venez de récupérer\n\nFaites une requête avec la méthode GET sur la ressource suivante. Qu’obtenez-vous ?\n\nweb-services.domensai.ecole/attack?type_attack_id={id_type}\nen remplaçant {id_type} par un entier entre 1 et 4.\n\nFaites une requête avec la méthode GET sur la ressource suivante\n\nweb-services.domensai.ecole/attack?type_attack_name={type attack}\nen remplaçant {type attack} par special attack ou physical attack ou fixed damage ou status attack\n\nFaites une requête de type POST sur la ressource suivante\n\nweb-services.domensai.ecole/attack\nCliquer sur Body, puis JSON, coller le texte ci-dessous, puis remplacez les valeurs des attributs pour créer votre propre attaque\n\n{\n  \"name\": \"An awesome name\",\n  \"attack_type\": \"physical attack\"/\"physical attack\"/\"fixed damage\"/\"status attack\",\n  \"power\": 0,\n  \"accuracy\": 0,\n  \"element\": \"An awesome element\",\n  \"description\": \"An awesome description\"\n}\nFaites une requête avec la méthode GET sur la ressource suivante\n\nweb-services.domensai.ecole/attack/{identifier}\nen remplaçant {identifier} par le nom ou l’id de l’attaque que vous venez de créer\n\n\n\n\n\n1.4 Swagger\nDans votre navigateur web allez sur la page http://web-services.domensai.ecole/docs. Cela vous amène sur la page swagger du webservice. Cette page recense tous les endpoints du webservice, et comment les utiliser. Essayez via l’interface de :\n\nmodifier une attaque\nsupprimer une attaque\nafficher une liste de pokémon\najouter un pokémon"
  },
  {
    "objectID": "doc/tp/tp2.html#appeler-un-webservice-en-python",
    "href": "doc/tp/tp2.html#appeler-un-webservice-en-python",
    "title": "Webservices et formats de données",
    "section": "2 Appeler un webservice en python",
    "text": "2 Appeler un webservice en python\nAujourd’hui, les plus grands consommateurs de webservices sont les machines. Et donc maintenant nous allons voir comment automatiser des appels à un webservice en python.\n\n🔍 Aujourd’hui beaucoup d’applications web (par exemple Facebook, Netflix, Dailymotion, Uber) utilisent ce que l’on appelle des architectures “micro services”.\nLes échanges entre leurs composants applicatifs (par exemple entre leurs interface homme machine (IHM) et leurs services internes) se font via des webservices à but unique. Cela permet d’avoir des modules découplés les uns des autres car ils communiquent uniquement via requête HTTP, ou avec des systèmes de gestion d’évènements. Ils ont seulement à savoir comment ils doivent communiquer les uns avec les autres et pas le fonctionnement interne des autres modules.\nLe côté négatif c’est que cela demande de bien documenter ses webservices et de gérer ÉNORMÉMENT d’applications en parallèle. Amazon, Google, Facebook peuvent se le permettre, par contre une petite entreprise de 10 employés non.\n\n\n\n2.1 La bibliothèque requests - Comment ça fonctionne\nLe principe va rester le même que faire une requête à la main, et on va utiliser la bibliothèque requests pour avoir seulement à remplir les parties intéressantes de nos requêtes.\nPour faire une requête GET vous allez seulement devoir faire :\nimport requests\n\nresponse = requests.get(\"http://mon-webservice.com\") \nExécuter cette ligne de code va :\n\nEnvoyer la requête au serveur que vous contactez\nStockez le résultat dans la variable response\n\nCette variable response est un objet, et comme tout objet elle a des attributs et des méthodes, par exemple :\n\nresponse.text : le corps du résultat sous forme de string en laissant requests inférer l’encodage (cela fonctionne souvent). Problème vous avez seulement un string, et ce n’est pas le meilleur format de données à manipuler\nresponse.json() : le corps du résultat comme un dict. C’est ce que vous allez faire le plus souvent car le format json est un format simple à manipuler\nresponse.encoding : l’encoding de votre requête (utile en cas de problème d’encoding)\nresponse.status_code : le statut de la requête. les principaux sont :\n\n200 : retour général pour dire que tout c’est bien passé\n201 : ressource créée avec succès\n202 : requête acceptée, sans garantie du résultat (par exemple dans un système asynchrone)\n400 : erreur de syntaxe dans la requête\n401 : erreur, une authentification est nécessaire\n403 : la ressource est interdite (droits insuffisants)\n404 : ressource non trouvée\n405 : une mauvaise méthode http a été utilisée\n500 : erreur côté serveur\n503 : service temporairement indisponible\n\n\nPour résumer, les résultats 2xx indiquent un succès, un résultat 4xx ou 5xx un problème.\nExemple simple d’utilisation :\nimport requests\nimport json\n\nresponse = requests.get(\"http://mon-webservice.com\")\n\nif response.status_code != 200:\n    raise Exception(\n        \"Cannot reach (HTTP {}): {}\".format(response.status_code, response.text)\n    )\nelse:    \n    print(json.dumps(response.json(), indent=2))       # JSON Pretty print\n\n\n2.2 Mise à jour de votre dépôt git\n2 possibilités au choix\n\n2.2.1 Si vous voulez repartir du code du TP1\n\nOuvrez Visual Studio Code\n\nFile &gt; Open Folder\n\nAllez dans /p/Cours2A/UE3_Complements_informatique/TP/TP1\ncliquez une fois sur ENSAI-2A-complement-info-TP\npuis sur le bouton Sélectionner un dossier\n\nOuvrez un Terminal Git Bash dans VSCode (Terminal &gt; New terminal)\nCréez un point de sauvegarde de vos travaux de la semaine dernière\n\ngit add .\ngit commit -m \"Mon super code du TP1\"\n\nMettez à jour votre dépôt local\n\ngit pull\n\nPassez sur la branche du TP2\n\ngit checkout tp2_base\n\n\n\n\n\n2.2.2 Si vous n’avez pas le code du TP1 sur votre machine\n\nOuvrez le logiciel Git Bash\n\nCréez un dossier pour stocker le code du TP\n\npar exemple, copiez la ligne ci-dessous, et collez là dans Git Bash (clic droit &gt; Paste)\nmkdir -p /p/Cours2A/UE3_Complements_informatique/TP/TP2 && cd $_\n\nClonez le dépôt\n\ngit clone https://github.com/ludo2ne/ENSAI-2A-complement-info-TP.git\n\nFermez Git Bash\n\nOuvrez Visual Studio Code\n\nFile &gt; Open Folder\n\nAllez dans /p/Cours2A/UE3_Complements_informatique/TP/TP2\ncliquez une fois sur ENSAI-2A-complement-info-TP\npuis sur le bouton Sélectionner un dossier\n\nOuvrez un Terminal Git Bash dans VSCode (Terminal &gt; New terminal)\nPassez sur la branche du TP2\n\ngit checkout tp2_base\n\n\n\n\n\n2.2.3 ⚠️ Attention quand vous faites Open Folder dans VSCode\nLe dossier parent de l’explorer de VSCode (à gauche) doit être : ENSAI-2A-complement-info-TP. Si c’est TP1, TP2, TP ou autre chose ce n’est pas bon ! Vous allez avoir des soucis d’imports par la suite.\n\nPour pour vérifier que tout fonctionne : * lancez le fichier __main__.py * lancez les tests unitaires du package business_object * dans terminal : python -m unittest -k test_business_object\n\n\n\n\n2.3 Mes premières requêtes en Python\n✍️ Hands on 3\n\nSi ce n’est pas déjà fait (voir README.md), installez dotenv\n\npip install python-dotenv\n\nOuvrez le fichier /src/client/attack_client.py\nComplétez la méthode get_attack(int)\n\nprend en paramètre un id d’attaque\nva chercher toutes les informations disponibles sur cette attaque\nretourne un objet de type AbstractAttack\n\nPour vous aider, observez la méthode instantiate_attack() de la classe AttackFactory\nRegardez le fonctionnement de cette méthode et utilisez la\n\n\ncréez la méthode get_all_attacks()\n\nretourne la liste de tous les attaques disponibles sous la forme d’une liste d’objets AbstractAttack\n\nVérifiez que vos 2 méthodes fonctionnent\n\nLancez les tests unitaitres du package test_client\n\n\n\n\n\n2.4 Les requêtes plus complexes\nPour le moment nous nous sommes concentrés sur les requêtes GET mais il est bien sûr possible d’en faire d’autre. Par exemple pour les requêtes POST, PUTou DELETE voici la syntaxe :\npost = requests.post(\"http://example.org\", json = {'key':'value'})\nput = requests.put(\"http://example.org\", json = {'key':'value'})\ndelete = requests.delete(\"http://example.org\")\nComme vous le voyez, les syntaxes sont très proches de la syntaxe de la méthode GET. On a seulement ajouté pour certaines requêtes des données. C’est ce que vous avez fait plus tôt avec Insomnia. Pour passer des paramètres à votre requête je vous conseille néanmoins de préférer ce genre de syntaxe :\nurl = \"http://example.org\"\ndata = {'key':'value'}\npost = requests.post(url, json = data)\nC’est la même chose fonctionnellement, mais il vaut mieux définir les éléments hors de la requête pour ne pas se perdre.\nIl est également possible de passer des entêtes http en ajoutant l’attribut headers à la fonction utilisée.\nheaders = {'accept': 'application/xml'}\nrequests.get('http://example.org', headers=headers)\n\n\n2.5 Requêtes avancées en python\n✍️ Hands on 4\n\nDans le module attack_client.py implémentez les méthodes suivantes :\n\ncreate_attack(AbstractAttack)\n\nprend une AbstractAttack en paramètre\ncrée une nouvelle ressource dans notre webservice\n\nupdate_attack(AbstractAttack)\n\nprend une AbstractAttack en paramètre\nmodifie la ressource associée dans notre webservice\n\ndelete_attack(AbstractAttack)\n\nprend une AbstractAttack en paramètre\nsupprime la ressource associée dans notre webservice\n\n\nTestez vos méthodes"
  },
  {
    "objectID": "doc/tp/tp2.html#coder-un-webservice-en-python",
    "href": "doc/tp/tp2.html#coder-un-webservice-en-python",
    "title": "Webservices et formats de données",
    "section": "3 Coder un webservice en python",
    "text": "3 Coder un webservice en python\nAvec les outils à disposition aujourd’hui il est facile de faire un webservice soit même.\nIl y a trois leaders sur le marché actuellement pour faire un webservice REST en python: * Django REST, * FlaskRESTful * FastAPI\nChacun à ses avantages et inconvénients. Django est sûrement le plus complet mais le plus lourd, Flask et FastApi sont plus légers et rapides à mettre en place. Le gros avantage de FastApi est la simplicité pour créer une page swagger de documentation.\nVoici le code minimal d’un webservice REST avec FastAPI (documentation officielle)\nfrom fastapi import FastAPI\n\n# On instancie le webservice\napp = FastAPI()\n\n# Création d'un enpoint qui répond à la méthode GET à l'adresse \"/\" qui va retourne le message \"Hello World\"\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello World\"}\n\n# Lancement de l'application sur le le port 80\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=80)\nAppeler la ressource “/” du webservice va retourner le json : {\"message\": \"Hello World\"}\nVoici un exemple plus complet inspiré de la documentation officielle (vous voulez créer un webservice pour exposer vos todos)\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\nfrom starlette import status\nimport uvicorn\n\n# On instancie le webservice\napp = FastAPI()\n\nclass Todo(BaseModel):\n    id : int\n    content : str\n\ntodos = {1 : Todo(1,\"Step 1 : Learn python\")\n        , 2 : Todo(2,\"Step 2 : Work on the IT project\")\n        , 3 : Todo(3,\"Step 3 : ???\")\n        , 4 : Todo(4,\"Step 4 : Profit\")}\n\n# Définition du endpoint get /todo\n@app.get(\"/todo\")\nasync def get_all_todo():\n    return todos.values()\n\n# Définition du endpoint get /todo/{id_doto}\n@app.get(\"/todo/{id_toto}\")\nasync def get_todo_by_id(id_toto : int = Path(..., description = \"The `id` of the todo you want to get\")):\n    if todos.get[id_toto] :\n        return todos.get[id_toto]\n    else :\n        return JSONResponse(status_code=status.HTTP_404_NOT_FOUND)\n\n# Définition du endpoint post /todo\n@app.post(\"/todo\", todo, status_code=201)\nasync def post_todo(todo:Todo):\n    if not todos.get(todo.id):\n        return JSONResponse(status_code=status.HTTP_409_CONFLICT)\n    else :\n        todos[todo.id] = todo\n        return todo\n\n# Lancement de l'application sur le le port 8XXX avec XXX les 3 derniers numéros de votre id\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8XXX)\nCe code va créer un web service qui va répondre aux requêtes suivantes :\n\nGET host/todo : retourne toutes les tâches à faire\nGET host/todo/{todo_id} : retourne la tâche derrière l’id en paramètre\nPOST host/todo/ : ajoute la tâche passée en corps de la rêquete\n\nFastAPI sérialise pour vous les objets que vous retournez. Donc pas besoin de mettre en forme vos données. Néanmoins, pour plus de clarté, vous pouvez utiliser des classes BaseModel. Ce sont des classes qui ne vont contenir que des attributs que vous pouvez déclarer sans constructeur:\nclass Todo(BaseModel):\n    id : int\n    content : str\nCes classes peuvent être utilisées en sortie de votre webservice, comme en entrée (ligne 33). FastApi va faire pour vous tout une série de contrôle sur les types des variables et renvoyer une erreur au client si sa requête n’est pas bien formatée.\nFondamentalement un webservice est une application comme les autres, mais au lieu d’avoir une interface graphique comme on en a l’habitude en tant qu’humain, l’interface est une interface HTTP qui va accepter des requêtes et envoyer des résultats. Ainsi le diagramme de séquence des différentes couches qui vont être impliquées dans une requête GET pour récupérer une ressource va ressembler à cela si je reprends le modèle 3 couches vu en cours.\n\n\n\n\n\nsequenceDiagram\n    participant U as User\n    participant R as Webservice\n    participant S as Service\n    participant D as DAO\n    participant B as Base de données\n    U -&gt;&gt; R : HTTP requête\n    R -&gt;&gt; S : get_by_id()\n    S -&gt;&gt; D : find_by_id()\n    D -&gt;&gt; B : requête SQL (psycopg)\n    B -&gt;&gt; D : curseur SQL (psycopg)\n    D -&gt;&gt; S : instance objet metier\n    S -&gt;&gt; R : instance objet metier\n    Note over S,R: l'objet est potentiellement altéré\n    R -&gt;&gt; U : Réponse HTTP\n\n\n\n\n\n\n\n3.1 Mon premier webservice\n\nVérifiez que le module fastapi est installé (pip list)\n\nSi ce n’est pas le cas : pip install \"fastapi[all]\"\n\nOuvrez le fichier app.py\nLancez ce fichier\n\ntestez les requêtes suivantes :\n\nGET http://localhost/hello\nGET http://localhost/hello/everybody\n\n\nArrétez le webservice\n\nCliquez dans le terminal de VSCode puis CTRL + C\n\n\n✍️ Hands on 5\nEn utilsant la liste de personnages définie dans le fichier app.py, ajoutez les endpoints suivants : * [ ] GET localhost:80/character : retournera un json contenant une liste des personnages * [ ] PUT localhost:80/character/{id} qui modifiera le nom du personnage à l’index {id} à partir d’un body * [ ] DELETE localhost:80/character/{id} qui supprimera l’élément à l’index {id}\nPour tester les endpoints nécessitant un body json, vous pouvez utiliser 👎\n{\n  \"nom\":\"Agneta\",\n  \"age\": 30\n}"
  },
  {
    "objectID": "doc/tp/tp3.html",
    "href": "doc/tp/tp3.html",
    "title": "Data Access Objet (DAO)",
    "section": "",
    "text": "😱 Comme vous pouvez le constater le sujet de ce TP est lui aussi long. Cela ne doit pas vous effrayer. Il mélange explications complètes et manipulations pour être au maximum autosuffisant. Vous n’allez surement pas terminer le sujet, ce n’est pas grave. Il est là pour vous aider lors du projet informatique.\nCe TP mêle explications pour vous faire comprendre ce qui est fait, et phases de manipulation ou code. Ces phases sont appelées “✍️Hands on”. C’est à ce moment-là que vous devez faire ce qui est écrit dans le TP. Les explications de ce TP ne doivent pas prendre le pas sur celles de votre intervenant. Prenez-les comme une base de connaissances pour plus tard, mais préférez toujours les explications orales.\n\nDans ce TP vous allez :\n\nRevoir des notions de base de données relationnelles ;\nImplémenter le patron de conception DAO ;\nVoir si votre programme fonctionne avec des tests unitaires reproductibles."
  },
  {
    "objectID": "doc/tp/tp3.html#avant-de-commencer",
    "href": "doc/tp/tp3.html#avant-de-commencer",
    "title": "Data Access Objet (DAO)",
    "section": "",
    "text": "😱 Comme vous pouvez le constater le sujet de ce TP est lui aussi long. Cela ne doit pas vous effrayer. Il mélange explications complètes et manipulations pour être au maximum autosuffisant. Vous n’allez surement pas terminer le sujet, ce n’est pas grave. Il est là pour vous aider lors du projet informatique.\nCe TP mêle explications pour vous faire comprendre ce qui est fait, et phases de manipulation ou code. Ces phases sont appelées “✍️Hands on”. C’est à ce moment-là que vous devez faire ce qui est écrit dans le TP. Les explications de ce TP ne doivent pas prendre le pas sur celles de votre intervenant. Prenez-les comme une base de connaissances pour plus tard, mais préférez toujours les explications orales.\n\nDans ce TP vous allez :\n\nRevoir des notions de base de données relationnelles ;\nImplémenter le patron de conception DAO ;\nVoir si votre programme fonctionne avec des tests unitaires reproductibles."
  },
  {
    "objectID": "doc/tp/tp3.html#mise-à-jour-de-votre-dépôt-local",
    "href": "doc/tp/tp3.html#mise-à-jour-de-votre-dépôt-local",
    "title": "Data Access Objet (DAO)",
    "section": "1 Mise à jour de votre dépôt local",
    "text": "1 Mise à jour de votre dépôt local\nComme lors du précédent TP, vous avez 2 possibilités pour récupérer le code de base du TP3 :\n\n1.0.1 Si vous voulez repartir du code du TP2\n\nOuvrez Visual Studio Code\n\nFile &gt; Open Folder\n\nAllez dans /p/Cours2A/UE3_Complements_informatique/TP/TP2\ncliquez une fois sur ENSAI-2A-complement-info-TP\npuis sur le bouton Sélectionner un dossier\n\nOuvrez un Terminal Git Bash dans VSCode (Terminal &gt; New terminal)\nCréez un point de sauvegarde de vos travaux de la semaine dernière\n\ngit add .\ngit commit -m \"Mon super code du TP2\"\n\nMettez à jour votre dépôt local\n\ngit pull\n\n\n\n\n\n1.0.2 Si vous n’avez pas le code du TP2 sur votre machine\n\nOuvrez le logiciel Git Bash\n\nCréez un dossier pour stocker le code du TP\n\npar exemple, copiez la ligne ci-dessous, et collez là dans Git Bash (clic droit &gt; Paste)\nmkdir -p /p/Cours2A/UE3_Complements_informatique/TP/TP3 && cd $_\n\nClonez le dépôt\n\ngit clone https://github.com/ludo2ne/ENSAI-2A-complement-info-TP.git\n\nFermez Git Bash\n\nOuvrez Visual Studio Code\n\nFile &gt; Open Folder\n\nAllez dans /p/Cours2A/UE3_Complements_informatique/TP/TP2\ncliquez une fois sur ENSAI-2A-complement-info-TP\npuis sur le bouton Sélectionner un dossier\n\nOuvrez un Terminal Git Bash dans VSCode (Terminal &gt; New terminal)\n\n\n\n\n\n1.0.3 ⚠️ Attention quand vous faites Open Folder dans VSCode\nLe dossier parent de l’explorer de VSCode (à gauche) doit être : ENSAI-2A-complement-info-TP. Si c’est TP1, TP2, TP3, TP ou autre chose ce n’est pas bon ! Vous allez avoir des soucis d’imports par la suite.\n\n\n\n1.0.4 Dans les 2 cas\n\nPassez sur la branche du TP3\n\ngit checkout tp3_base\n\nSi ce n’est pas déjà fait, installez les dépendances nécessaires (voir fichier README)\n\npip install -r requirements.txt\n\npour pour vérifier que tout fonctionne bien\n\nlancez le fichier __main__.py\nlancez les tests unitaires\n\ndans terminal : python -m unittest\n\n\nPour pouvoir vous connecter à votre base de données, renseignez les variables du fichier .env avec votre id :\n\nDATABASE=id????\nUSER=id????\nPASSWORD=id????\n\nLancez le script utils/reset_database.py\n\ncela crée un schéma et des données utiles pour ce TP\n\nOuvrez DBeaver pour une remise en jambes en SQL\n\nSi vous n’êtes pas familier avec DBeaver, suivez ces instructions\nobservez ces tables et leurs liens : tp.pokemon, tp.pokemon_type, tp.attack, tp.attack_type, tp.pokemon_attack (schéma dans TP/img/)\nécrivez des requêtes pour :\n\nlister toutes les attaques, ainsi que le nom du type d’attaque\nlister tous les pokemon, ainsi que le nom du type de Pokemon\nlister toutes les attaques de Pikachu\n\ngardez ces requêtes de coté, elles seront utiles plus loin"
  },
  {
    "objectID": "doc/tp/tp3.html#data-access-objet-dao",
    "href": "doc/tp/tp3.html#data-access-objet-dao",
    "title": "Data Access Objet (DAO)",
    "section": "2 Data Access Objet (DAO)",
    "text": "2 Data Access Objet (DAO)\n\n2.1 Modélisation\nReprenons le diagramme de classe du TP1. Limitons nous à la partie “attaque” et réfléchissons où mettre une méthode qui permet de persister les attaques.\n\n\n\n\n\nclassDiagram\n\nclass AbstractAttack{\n    &lt;&lt;abstract&gt;&gt;\n    + DATABASE_TYPE_LABEL : str\n    # _id : int\n    # _power : int\n    # _name : str\n    # _description : str\n    +compute_damage(APkm, APkm)$  int\n    }\n    class FixedDamageAttack{\n        + compute_damage(APkm,APkm )  int\n    }\n    class AbstractFormulaAttack{\n    &lt;&lt;abstract&gt;&gt;\n        -get_attack_stat(APkm)$  float\n        -get_defense_stat(APkm)$  float\n        +compute_damage(APkm,APkm)  int\n    }\n    \n    class PhysicalAttack{\n        -get_attack_stat(APkm)  float\n        -get_defense_stat(APkm)  float\n    }\n    \n    class SpecialAttack{\n        -get_attack_stat(APkm)  float\n        -get_defense_stat(APkm)  float\n    }\n    \n    FixedDamageAttack--|&gt;AbstractAttack\n    AbstractFormulaAttack--|&gt;AbstractAttack\n    SpecialAttack--|&gt;AbstractFormulaAttack\n    PhysicalAttack--|&gt;AbstractFormulaAttack\n\n\n\n\n\n\n\n\nVu que les attributs de nos attaques sont similaires, on ne va pas coder ça dans les classes spécifiques des attaques. On pourrait mettre les méthodes dans AbstractAttack. Ça fonctionnerait bien d’ailleurs. On aurait une classe unique avec nos méthodes pour interagir avec la base. Mais on ne va pas faire ça !\nEt là vous vous demandez :\n\n😱 Mais pourquoi ???\n\nEt la réponse est :\n\n😛 Car ça n’a aucun sens !\n\nRevenons sur la phrase : faible couplage, forte cohésion. Si l’on met toutes les méthodes de persistance de nos attaques dans la classe AbstractAttack on va avoir une classe qui :\n\n✔️ Détermine le comportement des attaques. C’est exactement ce que l’on souhaite (forte cohésion).\n❌ Détermine comment on persiste une attaques.\n\nMais ça, ce n’est pas de la responsabilité d’une attaque, mais du système de persistance choisi, ou du moins de l’intermédiaire entre nos objets et le système de persistance !\nJe n’ai personnellement pas envie d’aller modifier ma classe AbstractAttack uniquement car j’ai décidé de changer de système de gestion de la persistance. Je risque de modifier quelque chose que je ne devrais pas et créer des régressions (faire apparaitre des erreurs sur un code qui n’en avait pas avant) dans mon code. Or j’aimerais bien limiter les sources d’erreurs.\nÀ la place, nous allons créer une classe qui va s’occuper uniquement de cette tâche. Et on appelle ce type de classe DAO pour Data Access Object. C’est une classe technique qui va faire l’interface entre nos données stockées et notre application. Voilà ce que cela donne en terme de diagramme de classe\n\n\n\n\n\nclassDiagram\n\nclass AbstractAttack{\n    &lt;&lt;abstract&gt;&gt;\n    + DATABASE_TYPE_LABEL : str\n    # _id : int\n    # _power : int\n    # _name : str\n    # _description : str\n    +compute_damage(APkm, APkm)$  int\n    }\n    class FixedDamageAttack{\n        + compute_damage(APkm,APkm )  int\n    }\n    class AbstractFormulaAttack{\n    &lt;&lt;abstract&gt;&gt;\n        -get_attack_stat(APkm)$  float\n        -get_defense_stat(APkm)$  float\n        +compute_damage(APkm,APkm)  int\n    }\n    \n    class PhysicalAttack{\n        -get_attack_stat(APkm)  float\n        -get_defense_stat(APkm)  float\n    }\n    \n    class SpecialAttack{\n        -get_attack_stat(APkm)  float\n        -get_defense_stat(APkm)  float\n    }\n    \n    FixedDamageAttack--|&gt;AbstractAttack\n    AbstractFormulaAttack--|&gt;AbstractAttack\n    SpecialAttack--|&gt;AbstractFormulaAttack\n    PhysicalAttack--|&gt;AbstractFormulaAttack\n\n\nclass AttackDao{\n&lt;&lt;Singleton&gt;&gt;\n +create(AbstractAttack) AbstractAttack\n +find_by_id(int) AbstractAttack\n +find_all() List[AbstractAttack]\n +update(AbstractAttack) AbstractAttack\n +delete(AbstractAttack) bool\n}\n\nclass DBConnection{\n&lt;&lt;Singleton&gt;&gt;\n-__connection : Connection\n\n+connection() Connection\n}\n\nAbstractAttack&lt;.. AttackDao: create\nAttackDao..&gt; DBConnection: use\n\n\n\n\n\n\n\n\n\n2.2 Gestion des connexions et patern singleton\nPour vous connecter à la base de données nous allons utiliser la bibliothèque python psycopg2. C’est elle qui va établir la connexion avec la base, envoyer nos requêtes et nous retourner les résultats.\nMais il faut faire un peu attention à la gestion des connexions. Car nous pourrions nous retrouver à ouvrir des centaines de connexions rapidement et dégrader les performances de notre application. C’est le travail de la classe DBConnection. Comme c’est un singleton, il y aura une seule instance de cette classe dans toute notre application, et comme c’est elle qui se connecte à la base on s’assure de l’unicité de la connexion.\n\nCette classe est une solution purement technique alors n’hésitez pas à la réutiliser pour votre projet. Elle introduit un concept avancé de POO, à savoir les méta classes. Une méta classe permet de modifier le comportement d’une classe à un niveau poussé (par exemple modifier comment les objets sont construits par python). À moins que vous ayez une appétence tout particulière pour l’informatique, ne passez pas de temps sur ce sujet.\n\n\n\n2.3 DAO et CRUD\nSi vous faites attention, les méthodes de notre DAO ressemblent à celles du CRUD. C’est normal car c’est dans ces méthodes que le code SQL va être stocké, donc il nous faut les méthodes de base, généralement :\n\nfind_all() : qui va retourner toute la table.\nfind_by_id() : qui retourne un enregistrement à partir de son id\ncreate() : qui crée un nouvel enregistrement\ndelete() : qui supprime un enregistrement\nupdate() : qui met à jour un enregistrement\n\nCes 5 méthodes suffisent pour communiquer avec votre base de données. Vous pouvez effectuer le reste des traitements dans vos classes Service. Néanmoins pour gagner du temps rien n’empêche de créer des méthodes plus complexes (ex : find_by_type_and_level_order_by_name_desc())\nVoici la fonctionnement général d’une des méthodes de la DAO :\n# Etape 1 : On récupère une connexion en utilisant la classe DBConnection.\nwith DBConnection().connection as connection :\n\n# Etape 2 : à partir de la connexion on fait un curseur pour la requête \n    with connection.cursor() as cursor : \n    \n    # Etape 3 : on exécute notre requête SQL.\n            cursor.execute(requete_sql)\n    \n    # Etape 4 : on stocke le résultat de la requête\n            res = cursor.fetchall()\n\nif res:\n    # Etape 5 : on agence les résultats selon la forme souhaitée (liste...)\n    \nreturn something\nL’objet cursor contient un pointeur vers les résultats de votre requête. Ce résultat n’est pas encore rapatrié sur votre machine, mais est stocké par la base de données. Vous avez 3 méthodes pour récupérer le résultat :\n\ncurseur.fetchone() : retourne uniquement un enregistrement sous forme de dictionnaire. Si vous appelez de nouveau fetchone() sur le même curseur vous obtiendrez la ligne suivante\ncursor.fetchall() : retourne l’intégralité des résultats sous forme d’une liste de dictionnaires.\n\nLes dictionnaires sont les lignes de la table récupérée.\nLes clés du dictionnaire sont les colonnes récupérées.\nCette méthode fonctionne très bien quand on veut tous les résultats en une fois et qu’il y en a peu. Quand on a des millions d’enregistrements cela va poser problème car :\n\nLe transfert de données sur internet va prendre du temps et bloquer notre application\nNotre application va devoir gérer une grande quantité de données, et elle en est peut-être incapable\n\n\ncurseur.fetchmany(size): retourne autant d’enregistrements que demandé sous forme d’une liste de dictionnaires. Cela permet de contrôler le volume de données que l’on traite. Si vous appelez de nouveau fetchmany(size) sur votre curseur, vous allez récupérer les lignes suivantes (système de pagination)\n\nPour plus d’information : article de pynative\n\n\n\n2.4 DAO avec des types d’attaque\n✍Hand on 1\n\nObservez le fonctionnement de la classe AttaqueTypeDAO\n\ncela va vous être utile pour la suite\n\nDans DBeaver, créez une requête qui retourne le contenu de la table tp.attack, ainsi que le champ attack_type_name de la table tp.attack_type\n\nCette requête servira pour les 2 méthodes find ci-après, car\n\nDans la classe AttaqueDao, créez les méthodes suivantes :\n\nupdate_attack(attack : AbstractAttack) -&gt; bool : met à jour les données de l’attaque passée en paramètre et retourne si la modification s’est bien passée\nfind_attack_by_id(id:int) -&gt; Optional[AbsractAttack] : retourne l’attaque avec l’id en paramètre ou retourne None si l’attaque n’est pas trouvée.\nfind_all_attacks() -&gt; List[AbsractAttack] : qui retourne la liste de toutes les attaques\n\nBonus : ajoutez à cette méthode les paramètres limit et offset\n\n\n\nVoici quelques conseils :\n\nVous pouvez utiliser l’attribut type de chaque attaque pour avoir son label en base\nUtilisez la classe AttackFactory pour instancier facilement des attaques\nPensez à faire des tests pour voir si votre code fonctionne\nDans les 2 méthodes find, pour créer nos objets métier Attack\n\nnous avons besoin de connaitre le nom du type d’attaque\nor il n’y a pas cette colonne dans la table attaque\nmais peut-être avez-vous déjà une requête qui fait le job ?\n\n\n\n\n\n2.5 Pokémon DAO\n✍Hand on 2\nCréez la classe PokémonDAO avec les méthodes suivantes :\n\nfind_all_pokemon()-&gt;List[AbstractPokemon] : retourne tous les pokémons dans la base\nfind_pokemon_by_name(name:str)-&gt;AbstractPokemon : retourne un pokémon avec le nom donné.\nComplétez la méthode ci-dessus en incorporant la liste des attaques du Pokemon :\n\nFaites une requête en joignant les tables attack et pokemon_attack en filtrant avec l’id du pokémon\nGénérez les attaques à partir de là\n\n\n\n\n\n2.6 DAO et webservice\n✍Hand on 3\nVous allez maintenant rendre accessible les données de votre base à d’autres utilisateurs en réalisant un webservice REST.\nAjoutez dans le fichier app.py les endpoints suivants :\n# Défintion du endpoint get /attack?limit=100\n@app.get(\"/attack/\")\nasync def get_all_attacks(limit:int):\n    # Vous devez récupérer les attaques en base en utilisant votre DAO\n    return attacks\n\n# Défintion du endpoint get /pokemon?limit=100\n@app.get(\"/pokemon/\")\nasync def get_all_pokemons(limit:int):\n    # Vous devez récupérer les pokemons en base en utilisant votre DAO\n    return pokemons\n\n# Défintion du endpoint get /pokemon`/{name}\n@app.get(\"/pokemon/{name}\")\nasync def get_pokemon_by_name(name:str):\n    # Vous devez récupérer le pokemon en base en utilisant votre DAO\n    return pokemon\n\nGET localhost:80/attack?limit=100 renverra une liste de 100 attaques par défaut. Il est possible de moduler cette valeur via le paramètre de requête limit\nGET localhost:80/pokemon?limit=100. Il renverra une liste de 100 pokémons par défaut, mais peut être modulé avec le paramètre de requête limit.\nGET localhost:80/pokemon/{nom}. Il renverra un json représentant un pokémon.\n\nPour retourner des objets, vous allez devoir définir des classes héritant de BaseModel. Vous trouverez toutes les infos dans la documentation de FastAPI."
  },
  {
    "objectID": "doc/tp/tp3.html#conclusion",
    "href": "doc/tp/tp3.html#conclusion",
    "title": "Data Access Objet (DAO)",
    "section": "Conclusion",
    "text": "Conclusion\nDans ce TP vous avez implémenté votre première DAO.\nC’est une classe technique qui sert à communiquer avec votre système de persistance de données. L’avantage premier de faire une classe à part est de découpler au maximum la gestion du système de persistance et le code métier de votre application.\nSi vous décidez d’arrêter d’utiliser une base de données relationnelle et préférez désormais une base de données no SQL vous allez devoir changer uniquement les classes DAO tout en exposant toujours les mêmes méthodes."
  },
  {
    "objectID": "doc/cours/intro.html",
    "href": "doc/cours/intro.html",
    "title": "Introduction",
    "section": "",
    "text": "6h CM\n12h TP\nludovic.deneuville@ensai.fr\nbureau 161\nsur la base des cours de Rémi Pépin\n\n\nPrésentation :\n\nINSEE, informatique, Orléans GEOLOC, Lille enquêtes, Nautile\nRémi Pépin, assistant d’enseignement entre 2018 et 2023\n\nCours de Cloud Computing\n\n\n\n\n\n\n\n\n\n\n\nBut du cours\n\n\n\nVous apporter les connaissances nécessaires pour mener à bien un projet informatique.\n\n\n\nConduire un projet\nDépasser les 50 lignes de code\nVivre la vie de développeur\nTravailler en équipe\n\n\n\norganiser votre code\n\n\n\n\n\n\nVersionnage avec git\nAnalyse fonctionnelle, génie logiciel\nProgrammation orientée objet avancée\nCommunication avec une base de données en python\nSécurité informatique\nCommunication client-serveur\n\n\n\n\n\nSettings VScode\nFormateur, Linter\nOpen Folder\n\n\n\nTP : truc à récup pour le projet\nRévisez les Pokemon\nSujets très longs\n\n\n\n\n\n\n🚧 date\n2h\nsur papier\n1 feuille A4 recto / verso manuscrite\n\n\n\nBut : voir si vous avez retenu le principal\npas de piège\nsur papier car TP trop compliqué à organiser, chatGPT\nMANUSCRITE : pas de photocopie\n\n\n\n\n\nPrésentation du projet"
  },
  {
    "objectID": "doc/cours/intro.html#cours-de-compléments-dinfo",
    "href": "doc/cours/intro.html#cours-de-compléments-dinfo",
    "title": "Introduction",
    "section": "",
    "text": "6h CM\n12h TP\nludovic.deneuville@ensai.fr\nbureau 161\nsur la base des cours de Rémi Pépin\n\n\nPrésentation :\n\nINSEE, informatique, Orléans GEOLOC, Lille enquêtes, Nautile\nRémi Pépin, assistant d’enseignement entre 2018 et 2023\n\nCours de Cloud Computing\n\n\n\n\n\n\n\n\n\n\n\nBut du cours\n\n\n\nVous apporter les connaissances nécessaires pour mener à bien un projet informatique.\n\n\n\nConduire un projet\nDépasser les 50 lignes de code\nVivre la vie de développeur\nTravailler en équipe\n\n\n\norganiser votre code\n\n\n\n\n\n\nVersionnage avec git\nAnalyse fonctionnelle, génie logiciel\nProgrammation orientée objet avancée\nCommunication avec une base de données en python\nSécurité informatique\nCommunication client-serveur\n\n\n\n\n\nSettings VScode\nFormateur, Linter\nOpen Folder\n\n\n\nTP : truc à récup pour le projet\nRévisez les Pokemon\nSujets très longs\n\n\n\n\n\n\n🚧 date\n2h\nsur papier\n1 feuille A4 recto / verso manuscrite\n\n\n\nBut : voir si vous avez retenu le principal\npas de piège\nsur papier car TP trop compliqué à organiser, chatGPT\nMANUSCRITE : pas de photocopie\n\n\n\n\n\nPrésentation du projet"
  },
  {
    "objectID": "doc/cours/intro-slides.html#cours-de-compléments-dinfo",
    "href": "doc/cours/intro-slides.html#cours-de-compléments-dinfo",
    "title": "Introduction",
    "section": "Cours de Compléments d’info",
    "text": "Cours de Compléments d’info\n\n6h CM\n12h TP\nludovic.deneuville@ensai.fr\nbureau 161\nsur la base des cours de Rémi Pépin\n\n\nPrésentation :\n\nINSEE, informatique, Orléans GEOLOC, Lille enquêtes, Nautile\nRémi Pépin, assistant d’enseignement entre 2018 et 2023\n\nCours de Cloud Computing"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Compléments d’informatiques",
    "section": "",
    "text": "Important\n\n\n\nCe site n’est plus mis à jour.\nLes cours et les TP sont désormais ici : https://ludo2ne.github.io/ENSAI-2A-Projet-info/"
  },
  {
    "objectID": "doc/cours/tests-unitaires-slides.html#les-tests",
    "href": "doc/cours/tests-unitaires-slides.html#les-tests",
    "title": "Les tests unitaires",
    "section": "Les Tests",
    "text": "Les Tests"
  },
  {
    "objectID": "doc/cours/tests-unitaires-slides.html#les-tests-unitaires",
    "href": "doc/cours/tests-unitaires-slides.html#les-tests-unitaires",
    "title": "Les tests unitaires",
    "section": "Les tests unitaires",
    "text": "Les tests unitaires\nNous allons utiliser le framework unittest pour réaliser nos tests en Python.\nCommençons par un exemple : vous souhaitez tester la méthode suivante :\nclass OperationMathematiques:\n    def diviser_cinq_par(self, nombre) -&gt; float:\n        if nombre != 0:\n            return 5 / nombre\n        else:\n            return None\nPour cela, vous allez créer une classe de test.\nLe premier test auquel on pense est le cas nominal : on choisit un nombre en entrée, par exemple 2, puis on vérifie que diviser_cinq_par(2) retourne bien la valeur attendue : 2.5\nfrom unittest import TestCase, TextTestRunner, TestLoader\nfrom mathematiques.operation_mathematique import OperationMathematiques\n\nclass TestOperationMathematiques(TestCase):\n    def test_diviser_cinq_par_nombre_non_nul(self):\n        ## GIVEN\n        nombre = 2\n\n        ## WHEN\n        resultat = OperationMathematiques().diviser_cinq_par(nombre)\n\n        ## THEN\n        self.assertEqual(resultat, 2.5)\nMais ce n’est pas suffisant !\nLa méthode a également un autre retour possible : None ➡️ il faut aussi tester que la méthode renvoie bien None si le paramètre en entrée est 0\nfrom unittest import TestCase, TextTestRunner, TestLoader\nfrom mathematiques.operation_mathematique import OperationMathematiques\n\nclass TestOperationMathematiques(TestCase):\n    def test_diviser_cinq_par_nombre_non_nul(self):\n        ## GIVEN\n        nombre = 2\n\n        ## WHEN\n        resultat = OperationMathematiques().diviser_cinq_par(nombre)\n\n        ## THEN\n        self.assertEqual(resultat, 2.5)\n\n    def test_diviser_cinq_par_zero(self):\n        ## GIVEN\n        nombre = 0\n\n        ## WHEN\n        resultat = OperationMathematiques().diviser_cinq_par(nombre)\n\n        ## THEN\n        self.assertIsNone(resultat)\n\nif __name__ == \"__main__\":\n    ## Run the tests\n    result = TextTestRunner(verbosity=2).run(\n        TestLoader().loadTestsFromTestCase(TestOperationMathematiques)\n    )\nVoici le test complet avec à la fin un main optionnel qui permet de lancer la classe de test comme n’importe quel programme Python avec le bouton ▶️\nEt si… on appelle la méthode avec ce paramètre : diviser_cinq_par(\"a\") ?\nVous pouvez aussi écrire un test pour vérifier que votre méthode renvoie bien une exception TypeError dans ce cas.\n    def test_diviser_cinq_string(self):\n        ## GIVEN\n        nombre = \"a\"\n\n        ## WHEN / THEN\n        with self.assertRaises(TypeError):\n            OperationMathematiques().diviser_cinq_par(nombre)\nMais il est quand même préférable de vérifier dans votre méthode que le paramètre est bien de type numérique et de décider quoi faire si ce n’est pas le cas.\n💡 Ce qu’il faut retenir sur le test unitaire :\n\nvérifie qu’une méthode fait ce qu’elle doit faire\nil faut tester les cas nominaux, mais également les cas à la marge et les erreurs\nun test unitaire teste UNE et UNE seule chose\n\nil faut autant de tests unitaires que de retours possibles\n\nil doit être le plus isolé possible (pas de question sur ce point à l’examen)\n\nc’est-à-dire que si vous voulez tester une méthode A, qui elle-même appelle d’autres méthodes B, C, D…\nle test ne doit se faire que sur la méthode A\nPour cela, il faut mocker le comportement des autres méthodes"
  },
  {
    "objectID": "doc/cours/tests-unitaires-slides.html#les-test-driven-development-tdd",
    "href": "doc/cours/tests-unitaires-slides.html#les-test-driven-development-tdd",
    "title": "Les tests unitaires",
    "section": "Les Test Driven Development (TDD)",
    "text": "Les Test Driven Development (TDD)\nQuand tester ?\n…\nLa meilleure pratique lorsque l’on veut créer une fonction est de d’abord créer les tests qui permettront de vérifier que la fonction fait ce qu’elle doit faire.\nCela peut paraître un peu étrange, mais en fait pas tant que ça. Lorsque vous codez une fonction, vous savez avant de commencer :\n\nquels seront les paramètres en entrée\nquels résultats vous attendez en sortie\ndonc vous avez déjà quoi tester !\n\nLa pratique du TDD a le gros avantage que cela nous force à écrire des tests et de prendre le temps de bien faire les choses. Pour adhérer au TDD il faut vraiment se faire violence au début, mais au final cette pratique est très bénéfique.\nSinon, si l’on écrit la fonction en premier, une fois que l’on a terminé, il y a 9 chances sur 10 que l’on se dise : “c’est bon ça marche, pas la peine de tester…”. Et ça c’est pas bien !!!\n\n\n\nHome — Tests unitaires"
  },
  {
    "objectID": "doc/cours/tests-unitaires.html",
    "href": "doc/cours/tests-unitaires.html",
    "title": "Les tests unitaires",
    "section": "",
    "text": "🚧"
  },
  {
    "objectID": "doc/cours/tests-unitaires.html#les-tests",
    "href": "doc/cours/tests-unitaires.html#les-tests",
    "title": "Les tests unitaires",
    "section": "Les Tests",
    "text": "Les Tests\n\nPourquoi tester ?\n\nPour vérifier que votre programme fonctionne\nPour détecter des erreurs\nPour éviter les régressions (quand vous modifiez du code)\n\nAucun test n’est parfait, mais cela permet quand même d’écarter de nombreuses erreurs.\nDes logiciels permettent de calculer la couverture de tests d’une application, c’est-à-dire approximativement le nombre de fonctions testées sur le nombre total de fonctions.\nCette couverture de tests est un indicateur de qualité. Cependant, elle donne une tendance, plutôt qu’une valeur fiable. En effet, il est facile de tester toutes les méthodes élémentaires pour augmenter mécaniquement sa couverture et de mettre de côté les tests sur les méthodes plus compliquées.\nPréférez faire peu de tests, mais des tests utiles !\n\n\nLes types de tests\nIl existe de très nombreux tests différents, voici les principaux :\n\nTest unitaire : teste une fonction pour vérifier son bon fonctionnement\nTest fonctionnel : teste les cas d’utilisation du logiciel\nTest de charge : évaluent la capacité d’un système à gérer un volume élevé de données ou de transactions\nTest d’intégration : vérifie que différents composants ou modules d’un système interagissent correctement ensemble\nTest d’intrusion : vérifie la sécurité du logiciel en recherchant des vulnérabilités et en simulant des attaques potentielles\n…"
  },
  {
    "objectID": "doc/cours/tests-unitaires.html#les-tests-unitaires",
    "href": "doc/cours/tests-unitaires.html#les-tests-unitaires",
    "title": "Les tests unitaires",
    "section": "Les tests unitaires",
    "text": "Les tests unitaires\nNous allons utiliser le framework unittest pour réaliser nos tests en Python.\nCommençons par un exemple : vous souhaitez tester la méthode suivante :\nclass OperationMathematiques:\n    def diviser_cinq_par(self, nombre) -&gt; float:\n        if nombre != 0:\n            return 5 / nombre\n        else:\n            return None\nPour cela, vous allez créer une classe de test.\nLe premier test auquel on pense est le cas nominal : on choisit un nombre en entrée, par exemple 2, puis on vérifie que diviser_cinq_par(2) retourne bien la valeur attendue : 2.5\nfrom unittest import TestCase, TextTestRunner, TestLoader\nfrom mathematiques.operation_mathematique import OperationMathematiques\n\nclass TestOperationMathematiques(TestCase):\n    def test_diviser_cinq_par_nombre_non_nul(self):\n        ## GIVEN\n        nombre = 2\n\n        ## WHEN\n        resultat = OperationMathematiques().diviser_cinq_par(nombre)\n\n        ## THEN\n        self.assertEqual(resultat, 2.5)\nMais ce n’est pas suffisant !\nLa méthode a également un autre retour possible : None ➡️ il faut aussi tester que la méthode renvoie bien None si le paramètre en entrée est 0\nfrom unittest import TestCase, TextTestRunner, TestLoader\nfrom mathematiques.operation_mathematique import OperationMathematiques\n\nclass TestOperationMathematiques(TestCase):\n    def test_diviser_cinq_par_nombre_non_nul(self):\n        ## GIVEN\n        nombre = 2\n\n        ## WHEN\n        resultat = OperationMathematiques().diviser_cinq_par(nombre)\n\n        ## THEN\n        self.assertEqual(resultat, 2.5)\n\n    def test_diviser_cinq_par_zero(self):\n        ## GIVEN\n        nombre = 0\n\n        ## WHEN\n        resultat = OperationMathematiques().diviser_cinq_par(nombre)\n\n        ## THEN\n        self.assertIsNone(resultat)\n\nif __name__ == \"__main__\":\n    ## Run the tests\n    result = TextTestRunner(verbosity=2).run(\n        TestLoader().loadTestsFromTestCase(TestOperationMathematiques)\n    )\nVoici le test complet avec à la fin un main optionnel qui permet de lancer la classe de test comme n’importe quel programme Python avec le bouton ▶️\nEt si… on appelle la méthode avec ce paramètre : diviser_cinq_par(\"a\") ?\nVous pouvez aussi écrire un test pour vérifier que votre méthode renvoie bien une exception TypeError dans ce cas.\n    def test_diviser_cinq_string(self):\n        ## GIVEN\n        nombre = \"a\"\n\n        ## WHEN / THEN\n        with self.assertRaises(TypeError):\n            OperationMathematiques().diviser_cinq_par(nombre)\nMais il est quand même préférable de vérifier dans votre méthode que le paramètre est bien de type numérique et de décider quoi faire si ce n’est pas le cas.\n💡 Ce qu’il faut retenir sur le test unitaire :\n\nvérifie qu’une méthode fait ce qu’elle doit faire\nil faut tester les cas nominaux, mais également les cas à la marge et les erreurs\nun test unitaire teste UNE et UNE seule chose\n\nil faut autant de tests unitaires que de retours possibles\n\nil doit être le plus isolé possible (pas de question sur ce point à l’examen)\n\nc’est-à-dire que si vous voulez tester une méthode A, qui elle-même appelle d’autres méthodes B, C, D…\nle test ne doit se faire que sur la méthode A\nPour cela, il faut mocker le comportement des autres méthodes"
  },
  {
    "objectID": "doc/cours/tests-unitaires.html#les-test-driven-development-tdd",
    "href": "doc/cours/tests-unitaires.html#les-test-driven-development-tdd",
    "title": "Les tests unitaires",
    "section": "Les Test Driven Development (TDD)",
    "text": "Les Test Driven Development (TDD)\nQuand tester ?\n…\nLa meilleure pratique lorsque l’on veut créer une fonction est de d’abord créer les tests qui permettront de vérifier que la fonction fait ce qu’elle doit faire.\nCela peut paraître un peu étrange, mais en fait pas tant que ça. Lorsque vous codez une fonction, vous savez avant de commencer :\n\nquels seront les paramètres en entrée\nquels résultats vous attendez en sortie\ndonc vous avez déjà quoi tester !\n\nLa pratique du TDD a le gros avantage que cela nous force à écrire des tests et de prendre le temps de bien faire les choses. Pour adhérer au TDD il faut vraiment se faire violence au début, mais au final cette pratique est très bénéfique.\nSinon, si l’on écrit la fonction en premier, une fois que l’on a terminé, il y a 9 chances sur 10 que l’on se dise : “c’est bon ça marche, pas la peine de tester…”. Et ça c’est pas bien !!!"
  },
  {
    "objectID": "doc/tp/tp1.html",
    "href": "doc/tp/tp1.html",
    "title": "Retour sur la POO, objets métier et patron de conception strategy",
    "section": "",
    "text": "Ce TP mêle explications et phases de code.\nLes explications de ce TP ne doivent pas prendre le pas sur celles de votre intervenant. Prenez les comme une base de connaissance pour plus tard, mais préférez toujours les explications orales."
  },
  {
    "objectID": "doc/tp/tp1.html#avant-de-commencer",
    "href": "doc/tp/tp1.html#avant-de-commencer",
    "title": "Retour sur la POO, objets métier et patron de conception strategy",
    "section": "",
    "text": "Ce TP mêle explications et phases de code.\nLes explications de ce TP ne doivent pas prendre le pas sur celles de votre intervenant. Prenez les comme une base de connaissance pour plus tard, mais préférez toujours les explications orales."
  },
  {
    "objectID": "doc/tp/tp1.html#introduction-et-mise-en-place",
    "href": "doc/tp/tp1.html#introduction-et-mise-en-place",
    "title": "Retour sur la POO, objets métier et patron de conception strategy",
    "section": "1 Introduction et mise en place",
    "text": "1 Introduction et mise en place\nVous allez créer les objets métier pour un jeu Pokémon.\nUn objet métier représente dans votre code quelque chose de concret, qui modèlise la réalité.\n\nObjet métier (business object) : représentation informatique d’un objet “réel” que notre programme va manipuler pour répondre à un besoin. Dans le cas de notre application cela sera des Pokémons, des attaques ou des objets.\nDans une application de e-commerce par exemple, les articles et comptes sont des objets métier. Ils permettent de séparer les données de l’application et les traitements. Cela conduit à avoir des objets contenant essentiellement des attributs et très peu de méthodes autre que des getter et setter.\n\nCe TP sera réalisé avec l’IDE (Integred Development Environment) Visual Studio Code.\n\n1.1 Importez le code du TP\n\nOuvrez Git Bash\nCréez un dossier pour stocker le code du TP\n\npar exemple, copiez la ligne ci-dessous, puis collez là dans Git Bash (clic droit &gt; Paste)\nmkdir -p /p/Cours2A/UE3_Complements_informatique/TP/TP1 && cd $_\n\nClonez le dépôt\n\ngit clone https://github.com/ludo2ne/ENSAI-2A-complement-info-TP.git\n\nOuvrez Visual Studio Code\n\nFile &gt; Open Folder\n\nAller dans /p/Cours2A/UE3_Complements_informatique/TP/TP1/ (ou dans le dossier où se situe le dépôt que vous venez de cloner)\ncliquer sur ENSAI-2A-complement-info-TP, puis sur le bouton Sélectionner un dossier\n⚠️ c’est très important de suivre très précisément ces consignes, sinon vous risquez d’avoir des soucis d’import !\n\n\n\nLisez le fichier README.md et suivez les instructions. Puis lancez le programme main.py pour vous assurer que tout fonctionne correctement.\n\nOuvrez un terminal dans VSCode (CTRL + ù)\n\nc’est le même terminal Git Bash que vous avez ouvert au début\nmais c’est plus pratique d’avoir tout au même endroit\n\nlistez les branches git branch -a\n\nVous avez la possibilité de consulter la correction en changeant de branche si et seulement si vous êtes bloqué trop longtemps.\nVoici quelques commandes git utiles :\n# Avant de changer de branches, créez un point de sauvegarde de votre travail\ngit add .\ngit commit -am \"&lt;message&gt;\"\n\n# changer de branche\ngit checkout &lt;nouvelle_branche&gt;      # dans le terminal, la branche courante est indiquéée entre ()\ngit checkout -                       # pour retourner à la branche précédente\n\n\n\n1.2 Ce que vous allez coder\nNotre jeu s’inspirera de Pokémon Unite (aucune connaissance du jeu, ni de Pokémon n’est nécessaire).\nPour résumer en quelques mots, voici les objets que nous allons manipuler :\n\nPokemon : qui ont diverses caractéristiques et statistiques\n\nhp : health points\nattack, defense, speed… : qui serviront déterminer la force de ses attaques\nun type : Attacker, Defender, All Rounder, Speedster, Supporter\n\nStatistic : pour éviter de surcharger la classe Pokemon, de nombreuses stats sont stockées dans un objet de la classe Statistic\nAttack : différents types d’attaques dont disposeront les Pokémons (partie 3)\nBattleService : servira à faire s’affronter 2 Pokémons pour déterminer l’issue du combat (partie 4)"
  },
  {
    "objectID": "doc/tp/tp1.html#modélisation-et-implémentation",
    "href": "doc/tp/tp1.html#modélisation-et-implémentation",
    "title": "Retour sur la POO, objets métier et patron de conception strategy",
    "section": "2 Modélisation et implémentation",
    "text": "2 Modélisation et implémentation\n\nDans un premier temps, nous allons coder uniquement les Pokemons (la classe Statistic est déjà codée). En fonction de son type, son coefficient d’attaque dépendra de diverses statistiques.\n\n\n\n\n\n\nclassDiagram\n class Pokemon {\n - __type : String\n - __current_stat : Statistique\n + get_pokemon_attack_coef() float\n }\n \n class Statistic {\n - __hp : int\n - __attaque : int\n - __defense : int\n - __spe_atk : int\n - __spe_def : int\n - __vitesse : int\n }\n Pokemon --&gt; Statistic : possède\n\n\n\n\n\n\nAvant d’écrire du code, nous allons réfléchir à la meilleure conception possible pour réaliser nos Pokémons. Notre conception essaiera au maximum de respecter la règle suivante : faible couplage, forte cohésion.\nEn d’autre termes nous allons essayer de faire :\n\ndes classes les plus disjointes possible (faible couplage) pour qu’une modification dans une classe ne nous demande pas de modifier les autres\ntout en essayant d’avoir les tâches réalisées par une seule classe les plus liées possible (forte cohésion).\n\n\n2.1 Première approche : le « if/elif/else » 💀\nOuvrez le code, et observez la classe Pokemon. Nous nous interessons à la méthode get_pokemon_attack_coef() qui va servir à déterminer la puissance de l’attaque en fonction du type de Pokémon.\n\n\nQuestion 1 : Expliquez pourquoi une implémentation à base de if/elif/else pour les types est une mauvaise idée ? Imaginez s’il y avait plusieurs blocs de code similaires dans notre application, et que nous devions ajouter un nouveau type.\n\n\n\n\n\n2.2 La puissance de la POO\nAu lieu d’externaliser les comportements de nos Pokémons, nous allons mettre tous leurs comportements spécifiques dans des classes filles d’une super classe Pokemon. Ceci est rendu possible grâce à deux propriétés des objets en POO :\n\nhéritage : il est possible de spécialiser une classe existante en modifiant son comportement, ou en ajoutant de nouveaux\npolymorphisme : deux fonctions peuvent avoir le même nom mais avoir des comportements différents\n\nEn plus, comme chacun de nos Pokémons va forcement être d’un type, aucun ne sera simplement de la classe Pokemon, cela nous permet de rendre cette classe abstraite. En définissant clairement notre classe abstraite nous allons avoir :\n\nUn plan pour toutes les classes qui en héritent. Cela à pour avantages de :\n\nDonner des informations sur la structuration du code\n\nPermettre de générer automatiquement les méthodes à définir\nLimiter les bug. Si on oublie une méthode, le code plante au démarrage, ce qui évite des comportements non prévus difficile à détecter\n\nUne interface unique pour tous les types de Pokémons. Quelque soit le type du Pokémon, il sera considéré comme un AbstractPokemon partout dans le code.\n\n\n\n\nQuestion 2 :\n\ntransformez la classe Pokemon en classe abstraite AbstractPokemon\n\nrenommez également le fichier en abstract_pokemon.py\n\ntransformez la méthode get_pokemon_attack_coef() en méthode abstraite\ncréez les classes Attacker, Defender et AllRounder qui héritent de AbstractPokemon\ndans ces 3 classes, implémentez la méthode get_pokemon_attack_coef()\n\n\n\nPour vous aider, voici le diagramme de classe :\n\n\n\n\n\nclassDiagram\n  class AbstractPokemon {\n    &lt;&lt;abstract&gt;&gt;\n    # _current_stat : Statistique\n    # _level : int\n    # _name : str\n    +get_pokemon_attack_coef() :  float\n  }\n  \n  class BattleService {\n    +resolve_battle() Battle\n  } \n \n  class Statistique {\n    - __hp : int\n    - __attaque : int\n    - __defense : int\n    - __spe_atk : int\n    - __spe_def : int\n    - __vitesse : int\n   }\n \n  AbstractPokemon &lt;|-- Attacker\n  AbstractPokemon &lt;|-- Defender\n  AbstractPokemon &lt;|-- AllRounder\n  AbstractPokemon --* Statistique\n  BattleService ..&gt;\"2\" AbstractPokemon : use\n\n\n\n\n\n\nVous devriez arriver à une arborescence proche de celle-ci :\n📦pokemon_unite_lite\n ┣ 📂business_object\n ┃ ┣ 📂pokemon\n ┃ ┃ ┣ 📜abstract_pokemon.py\n ┃ ┃ ┣ 📜attacker.py\n ┃ ┃ ┣ 📜defender.py\n ┃ ┃ ┗ 📜all_rounder.py\n ┃ ┗ 📜 statistique.py\n ┗ 📂service\n   ┗ 📜battle_service.py\nPour faire une classe abstraite, utilisez le package abc.\nVoici, pour vous inspirer, un exemple de ce qui est attendu :\n# Fichier abstract_personnage.py\nfrom abc import ABC, abstractmethod\n\nclass AbstractPersonnage(ABC):\n    def __init__(self, phrase_attaque:str, phrase_defense:str) -&gt; None:\n        self._phrase_attaque = phrase_attaque\n        self._phrase_defense = phrase_defense\n       \n    @abstractmethod # décorateur qui définit une méthode comme abstraite\n    def degat_attaque(self) -&gt; int:\n     pass\n\n# Fichier magicien.py\nfrom abstract_personnage import AbstractPersonnage\nclass Magicien(AbstractPersonnage):\n    def __init__(self) -&gt; None:\n        super().__init__(\"Lance une boule de feu\",\"Utilise une barrière magique\" )\n       \n    def degat_attaque(self) -&gt; int:\n        # code pour calculer les dégâts\n        return 10\n\n\n2.3 Testez votre code\n\n\nQuestion 3 : Testez la méthode get_pokemon_attack_coef() pour les classes AttackerPokemon et AllRounderPokemon.\nPour lancer tous les tests du projet, exécutez dans le terminal : python -m unittest\n\n\nPour cela vous allez utiliser le package unittest de python.\nCe package permet de réaliser des tests unitaires dans des classes séparées. L’avantage par rapport à doctest, c’est que les tests ne “polluent” pas vos classes, et qu’il est possible de patcher certains comportements des classes.\nUn exemple de test est donné dans la classe testDefenderPokemon. Pour rappel, un test se décompose en 3 parties :\n\nGIVEN : création des objets nécessaires à la réalisation du test\nWHEN : appel de la méthode à tester\nTHEN : vérification du résultat\n\nLes classes de test seront organisées de la manière suivante, en reproduisant l’architecture de votre application :\n📦pokemon_unite_lite\n ┣ 📂business_object\n ┃ ┣ 📂pokemon\n ┃ ┃ ┣ 📜abstract_pokemon.py\n ┃ ┃ ┣ 📜attacker.py\n ┃ ┃ ┣ 📜defender.py\n ┃ ┃ ┗ 📜all_rounder.py\n ┃ ┗ 📜 statistique.py\n ┣ 📂service\n ┃ ┗ 📜battle_service.py\n ┗ 📂test\n  ┗ 📂test_business_object\n      ┗ 📂test_pokemon\n        ┣ 📜test_abstract_pokemon.py\n        ┣ 📜test_attacker_pokemon.py\n        ┣ 📜test_defender_pokemon.py\n        ┗ 📜test_all_rounder_pokemon.py\n\n💡 Problèmes d’imports\n\nVérifiez que le dossier parent dans l’explorer de VSCode (à gauche) est : ENSAI-2A-complement-info-TP\n\nSi c’est TP1 ou TP ou autre chose ce n’est pas bon !\nSinon refaites : File &gt; open Folder\nCliquez une fois sur ENSAI-2A-complement-info-TP\nCliquez sur le bouton Sélectionner un dossier\nSi ça vous le demande, vous pouvez enregistrer vos modifications\n\nPréférez utiliser des chemins complets d’import plutôt que des chemins relatifs\n\nla racine des chemins est paramétrée au niveau du dossier src\ndonc cela donne par exemple : *from business_object.pokemon.abstract_pokemon import AbstractPokemon\n\ncar le dossier business_object est bien dans le dossier src\n\n\nCréez des fichiers __init__.py (vide)\n\ndans TOUS les dossiers que vous créez\nc’est un peu pénible mais ça peut débloquer la situation\n\n\n\n\n\nQuestion 4 : Pouvez-vous tester la méthode level_up() directement sur un AbstractPokemon ? Avez vous une idée comment faire ? (ne pas coder cette question)"
  },
  {
    "objectID": "doc/tp/tp1.html#lagrégation-lautre-façon-dajouter-de-la-souplesse-dans-le-code",
    "href": "doc/tp/tp1.html#lagrégation-lautre-façon-dajouter-de-la-souplesse-dans-le-code",
    "title": "Retour sur la POO, objets métier et patron de conception strategy",
    "section": "3 L’agrégation, l’autre façon d’ajouter de la souplesse dans le code",
    "text": "3 L’agrégation, l’autre façon d’ajouter de la souplesse dans le code\nMaintenant que nos Pokémons sont faits, nous allons y ajouter les attaques.\nNotre système va devoir respecter certaines contraintes :\n\nPlusieurs types d’attaques vont coexister, chacune avec un mode de calcul de dégâts différent :\n\nDes attaques à dégâts variables séparées en 2 types :\n\nattaques “physiques” qui utilisent l’attaque et la défense des Pokémons\nattaques “spéciales” qui utilisent l’attaque spé et la défense spé des Pokémons\n\nDes attaques à dégâts fixes qui font un nombre fixe de dégâts.\n\nUn pokémon peut avoir plusieurs attaques et le type de l’attaque doit être transparent pour le pokémon.\n\n\n\n3.1 Attaques à dégâts fixes\nNous allons commencer par les attaques à dégâts fixes. Comme il y aura un autre type d’attaques, toutes les attaques hériterons de la classe abstraite AbstractAttack déjà créée. Cette classe possède la méthode abstraite compute_damage() qui devra être implémentée dans les classes filles.\n\n\n\n\n\nclassDiagram\n\n  class AbstractAttack{\n    &lt;&lt;abstract&gt;&gt;\n    # _power : int\n    # _name : str\n    # _description : str\n    + compute_damage(APkm, APkm)$  int\n  }\n\n   class FixedDamageAttack{\n    + compute_damage(APkm,APkm )  int\n   }\n \n   AbstractAttack &lt;|-- FixedDamageAttack\n\n\n\n\n\n\n\n\nQuestion 5 Implémentez la classe FixedDamageAttack, ainsi que sa méthode compute_damage() qui retournera simplement la puissance (power) de l’attaque.\nCréez des tests pour vérifier que tout fonctionne correctement.\n\n\n\n\n\n3.2 Attaques à dégâts variables\nNous allons ensuite coder les attaques à dégâts variables. Elles utilisent la formule suivante :\nDamage = \\big ( \\frac{(\\frac{2*Level}{5}+2)* Power *Att}{Def*50} +2\\big) *random* other\\_multipliers\navec :\n\n\\(Att\\)​ : égal soit à l’attaque ou l’attaque spé du Pokemon attaquant\n\\(Def\\)​​ : égal soit à la défense ou défense spé du Pokemon défenseur\n\\(Power\\)​ : la valeur de puissance de l’attaque\n\\(random\\)​​ :une valeur comprise dans l’intervalle [0.85; 1]\n\\(other\\_ multipliers\\) : les autres multiplicateurs possibles, comme le coefficient d’attaque des pokémons.\n\nLa seule différence entre attaque physique et spéciale vient des coefficients \\(Att\\) et \\(Def\\), le reste de la formule des dégâts est identique. Nous allons donc utiliser le patron de conception template method, dont voici la modélisation UML dans notre cas :\n\n\n\n\n\nclassDiagram\n\n  class AbstractAttack{\n    &lt;&lt;abstract&gt;&gt;\n    # _power : int\n    # _name : str\n    # _description : str\n    + compute_damage(APkm, APkm)$  int\n  }\n\n   class FixedDamageAttack{\n    + compute_damage(APkm,APkm )  int\n   }\n\n  class AbstractFormulaAttack{\n    &lt;&lt;abstract&gt;&gt;\n    -get_attack_stat(APkm)$  float\n    -get_defense_stat(APkm)$  float\n    +compute_damage(APkm,APkm)  int\n  }\n \n  class PhysicalFormulaAttack{\n    -get_attack_stat(APkm)  float\n    -get_defense_stat(APkm)  float\n  }\n \n  class SpecialFormulaAttack{\n    -get_attack_stat(APkm)  float\n    -get_defense_stat(APkm)  float\n  }\n \n   AbstractAttack &lt;|-- FixedDamageAttack\n   AbstractAttack &lt;|-- AbstractFormulaAttack\n   AbstractFormulaAttack &lt;|-- SpecialFormulaAttack\n   AbstractFormulaAttack &lt;|-- PhysicalFormulaAttack\n\n\n\n\n\n\nLa classe AbstractFormulaAttack va contenir :\n\nla méthode compute_damage(pkmon_attacker: AbstratPokemon, pkmon_targeted: AbstractPokemon). Cette méthode va contenir la formule de calcul des dégâts, mais en appelant les méthodes get_attaque_stat(AbstractPokemon) et get_defense_stat(AbstractPokemon) pour savoir quelle statistique utiliser\nles méthodes abstraites get_attack_stat(AbstractPokemon) et get_defense_stat(AbstractPokemon). Ces méthodes devront être implémentées dans les classes filles pour déterminer quelles statistiques utiliser.\n\n\n\nQuestion 6 : Implémentez les 3 nouvelles classes et créez des tests pour vérifier que tout fonctionne correctement"
  },
  {
    "objectID": "doc/tp/tp1.html#architecture-finale-bonus-si-vous-avez-le-temps",
    "href": "doc/tp/tp1.html#architecture-finale-bonus-si-vous-avez-le-temps",
    "title": "Retour sur la POO, objets métier et patron de conception strategy",
    "section": "4 Architecture finale (bonus, si vous avez le temps)",
    "text": "4 Architecture finale (bonus, si vous avez le temps)\nNous allons maintenant rattacher les bouts pour créer notre architecture finale :\n\n\n\n\n\nclassDiagram\n  class AbstractPokemon {\n    &lt;&lt;abstract&gt;&gt;\n    # _current_stat : Statistique\n    # _level : int\n    # _name : str\n    # _attack_list : List~AbstractAttack~\n    +get_pokemon_attack_coef()$  float\n    +level_up() None\n  }\n \n  class Statistique {\n    - hp : int\n    - attaque : int\n    - defense : int\n    - spe_atk : int\n    - spe_def : int\n    - vitesse : int\n  }\n   \n  class BattleService {\n    + resolve_battle(APkm, APkm) : Battle\n    + get_order(APkm, APkm)\n    + choose_attack(APkm) : AAttack\n  }  \n  \n  class Battle{\n    - first_monstie : APkm\n    - second_monstie : APkm\n    - winner : APkm\n    - rounds : List&lt;Round&gt;\n  }\n\n  class Round{\n    attacker: APkm\n    defender: APkm\n    dealt_damage: int\n    attack_description: str\n  }\n  BattleService ..&gt;\"2\" AbstractPokemon : use\n  AbstractPokemon &lt;|-- Attacker\n  AbstractPokemon &lt;|-- Defender\n  AbstractPokemon &lt;|-- AllRounder\n  Statistique *-- AbstractPokemon\n\n  Battle .. BattleService\n  Battle .. Round\n \n  class AbstractAttack{\n    &lt;&lt;abstract&gt;&gt;\n    # _power : int\n    # _name : str\n    # _description : str\n    +compute_damage(APkm, APkm)$ int\n  }\n\n  class FixedDamageAttack{\n    + compute_damage(APkm,APkm )  int\n  }\n\n  class AbstractFormulaAttack{\n    &lt;&lt;abstract&gt;&gt;\n    -get_attack_stat(APkm)$  float\n    -get_defense_stat(APkm)$  float\n    + compute_damage(APkm,APkm ) int\n  }\n \n  class PhysicalFormulaAttack{\n   -get_attack_stat(APkm)$  float\n   -get_defense_stat(APkm)$  float\n  }\n \n  class SpecialFormulaAttack{\n    -get_attack_stat(APkm)  float\n    -get_defense_stat(APkm)  float\n  }\n \n  AbstractAttack &lt;|-- FixedDamageAttack\n  AbstractAttack &lt;|-- AbstractFormulaAttack\n  AbstractFormulaAttack &lt;|-- SpecialFormulaAttack\n  AbstractFormulaAttack &lt;|-- PhysicalFormulaAttack\n  BattleService &gt;.. AbstractAttack  : use\n  AbstractPokemon o--&gt;\"0..*\" AbstractAttack\n\n\n\n\n\n\n\n\n\nQuestion 7 : Implémentez le diagramme de classe ci-dessus et testez votre code en écrivant de nouveaux tests unitaires.\n\n\nCette architecture permet de décorréler les attaques des pokémons et de spécifier le comportement des attaques au fur et à mesure des héritages. Les avantages sont :\n\nPour la classe AbstractPokemon, toutes les attaques sont des AbstractAttack. Tant qu’elles exposent la méthode compute_damage notre programme va fonctionner. On peut ainsi facilement ajouter de nouveaux types d’attaques sans problème.\nUn Pokémon peut avoir des attaques de tous les types\nNous pouvons ajouter un système d’état comme la paralysie ou le poison assez facilement. Il faut pour cela modifier la classe AbstractAttack et les classes qui en héritent. Cela sera potentiellement long, mais ne demande pas de toucher à la partie “Pokémon” de notre architecture.\nUne personne pourrait se concentrer sur la création des Pokémons alors qu’une autre pourrait se concentrer sur celles des attaques sans difficulté. Les deux parties du code sont relativement indépendantes, la seule zone de couplage sont les classes AbstractPokemon et AbstractAttack, qui servent avant tout à définir ce qui doit être fait par les classes filles et ce qui est accessible à l’extérieur.\n\nLe fait d’externaliser le comportement des attaques dans des classes spécifiques puis de les lier aux Pokémons via une relation d’agrégation assez souple qui permet de changer dynamiquement les attaques d’un Pokémon est le patron de conception strategy."
  },
  {
    "objectID": "doc/tp/tp4.html",
    "href": "doc/tp/tp4.html",
    "title": "Git et Création d’une IHM",
    "section": "",
    "text": "😱 Comme vous pouvez le constater le sujet de ce TP est lui aussi long. Cela ne doit pas vous effrayer. Il mélange explications complètes et manipulations pour être au maximum autosuffisant. Vous n’allez surement pas terminer le sujet, ce n’est pas grave. Il est là pour vous aider lors du projet informatique.\nCe TP mêle explications pour vous faire comprendre ce qui est fait, et phases de manipulation ou code. Ces phases sont appelées “✍️Hands on”. C’est à ce moment-là que vous devez faire ce qui est écrit dans le TP. Les explications de ce TP ne doivent pas prendre le pas sur celles de votre intervenant. Prenez-les comme une base de connaissances pour plus tard, mais préférez toujours les explications orales.\nDans ce TP vous allez :\nLes instructions de ce TP seront données pour une utilisation de GitHub comme dépôt distant. Si vous choisissez GitLab ou un autre hébergeur, à vous de vous adapter (les instructions devraient être assez ressemblantes)."
  },
  {
    "objectID": "doc/tp/tp4.html#configuration-de-git",
    "href": "doc/tp/tp4.html#configuration-de-git",
    "title": "Git et Création d’une IHM",
    "section": "1 Configuration de Git",
    "text": "1 Configuration de Git\nPour faire d’un seul coup la config Git et la création d’un clé ssh, vous pouvez utiliser les scripts présents sur la page Moodle du cours, onglet TP. Sinon cela se fait également très vite avec les commandes ci-dessous.\n\n1.1 Configurez Git\nOuvrez Git Bash, puis éxécutez les commandes suivantes en remplaçant les valeurs entre &lt;&gt;\n\ngit config --global user.name &lt;prenom&gt; &lt;nom&gt;\ngit config --global user.email &lt;mail_ensai&gt;\ngit config --global core.mergeoptions --no-edit\ngit config --global core.editor \"code -w\"\ngit config --global credential.helper store\npour vérifier les valeurs saisies : git config -l\n\n\n\n\n1.2 Créez une clé ssh\nElle permettra de vous authentifier auprès de GitHub. Dans Git Bash :\n\nssh-keygen -t rsa -b 2048 -N '' -q -f ~/.ssh/id_rsa\nmkdir /p/save puis cp -r ~/.ssh /p/save/.ssh pour créer une sauvegarde de votre clé\n\nPar défaut la clé est générée dans C:/users/idxxxx/.ssh\nSi jamais cette clé venait à disparaitre, utilisez la sauvegarde pour la recopier dans C:/users/idxxxx/.ssh\n\ncat ~/.ssh/id_rsa.pub | clip\n\npour récupérer votre clé publique dans le presse papier\n\nOuvrez un éditeur de texte et collez cette clé\n\ngardez la de coté quelques minutes, vous allez devoir juste après coller cette clé dans GitHub\n\n\n\n\n\n1.3 Création de compte sur GitHub\n\nCréez un compte utilsateur\n\nhttps://github.com/join\n\nAjouter votre clé publique ssh sur GitHub (lien direct)\n\nCliquez sur votre icone profil en haut à droite\n⚙️ Settings\nSSH and GPG keys\nCliquer sur le bouton New SSH key\n\nTitre : VM ENSAI par exemple\nKey : Collez la clé publique (contenu du fichier id_rsa.pub qui commence par ssh-rsa généré à l’étape précédente )"
  },
  {
    "objectID": "doc/tp/tp4.html#travail-en-groupe",
    "href": "doc/tp/tp4.html#travail-en-groupe",
    "title": "Git et Création d’une IHM",
    "section": "2 Travail en groupe",
    "text": "2 Travail en groupe\n💡 Avec vos camarades de projet, vous devez choisir un site qui va héberger votre code (GitHub, GitLab…). Il vous servira de dépôt commun (ou dépôt distant).\n\n2.1 Création d’un dépôt sur GitHub\n\nRepositories &gt; New (ou lien direct)\nRepository name : ENSAI-2A-cinfo-TP4\nCliquez sur le bouton Create new repository\n\nPour le moment ce dépôt distant est vide\n\n\n\n2.2 Connecter ce dépôt avec un dépôt local\nDans les autres TP, vous aviez l’habitude de simplement cloner le dépôt distant du prof, faire les exercices et c’est tout.\nAujourd’hui, vous allez :\n\nCloner le dépôt distant\n\nPour créer votre dépôt local (jusque là, c’est toujours pareil)\n\nConnecter votre dépôt local à votre propre dépôt distant (celui que vous venez de créer)\nInteragir entre vos 2 dépôts (push, pull…)\n\n\n\nCréez un dossier puis importez le code du TP (branche tp4_base uniquement)\n\nmkdir -p /p/Cours2A/UE3_Complements_informatique/TP/TP4 && cd $_\ngit clone -b tp4_base --single-branch https://github.com/ludo2ne/ENSAI-2A-complement-info-TP.git\n\nModifiez le dépôt distant en déclarant le dépôt que vous avez créé juste avant\n\ncd ENSAI-2A-complement-info-TP pour vous positionner dans le dépôt local Git\ngit remote set-url origin git@github.com:&lt;username_github&gt;/ENSAI-2A-cinfo-TP4.git\n\nen remplaçant  par votre nom d’utilisateur GitHub\n\ngit remote -v pour vérifier que le dépôt distant a bien changé\n\ngit push pour pousser votre code local vers le dépôt GitHub\n\nRafraîchissez la page GitHub pour vérifier\n\n\n\n\n\n2.3 Utilisation d’un seul dépôt par équipe\nMaintenant vous allez travailler en tant qu’équipe de projet. Même si vous avez tous créé un dépôt git, un seul par groupe va être utilisé. Vous allez ainsi au sein d’une même équipe, récupérer le code de ce dépôt.\n⚠️ Choisissez LE dépôt que vous allez utiliser (1 seul par équipe projet) et faîtes les actions suivantes uniquement sur ce dépôt.\n\nSur la page GitHub du projet\n\nAller dans ⚙️ Settings &gt; Collaborators\nCliquer sur le bouton Add people, puis recherchez et ajoutez vos camarades\n\nou directement avec ce lien en remplaçant \n\nhttps://github.com/&lt;username_github&gt;/ENSAI-2A-cinfo-TP4/settings/access\n\n\n\n\n\n2.4 Import du dépôt commun pour les autres membres\nPour les autres, il vous faut maintenant tous récupérer le contenu du dépôt. Dans les commandes ci-dessous, remplacez  par le nom d’utilisateur de celui ou celle qui “possède” le dépôt commun.\n\nAllez sur la page GitHub du dépôt commun\n\nhttps://github.com//ENSAI-2A-cinfo-TP4\n\nCliquez sur le bouton Code\nCopiez le lien Clone with SSH qui ressemble à ceci : git@github.com:&lt;username_github&gt;/ENSAI-2A-cinfo-TP4.git\nDans Git Bash, créez un nouveau dossier pour mettre votre dépôt local\n\nmkdir -p /p/Cours2A/UE3_Complements_informatique/TP/TP4/depot_commun && cd $_\ngit clone git@github.com:&lt;username_github&gt;/ENSAI-2A-cinfo-TP4.git\nFermez Git Bash\n\nOuvrez Visual Studio Code, puis ouvrez le dépôt commun\n\nFile &gt; Open Folder\n\nAllez dans /p/Cours2A/UE3_Complements_informatique/TP/TP4/depot_commun\ncliquez une fois sur ENSAI-2A-cinfo-TP4\npuis cliquez sur le bouton Sélectionner un dossier\n\nOuvrez un Terminal Git Bash dans VSCode (Terminal &gt; New terminal)\n\n\n\n\n2.4.1 ⚠️ Attention quand vous faites Open Folder dans VSCode\nLe dossier parent de l’explorer de VSCode (à gauche) doit être : ENSAI-2A-complement-info-TP. Si c’est TP1, TP2, TP3, TP ou autre chose ce n’est pas bon ! Vous allez avoir des soucis d’imports par la suite."
  },
  {
    "objectID": "doc/tp/tp4.html#manipulations-basiques-avec-git",
    "href": "doc/tp/tp4.html#manipulations-basiques-avec-git",
    "title": "Git et Création d’une IHM",
    "section": "3 2. Manipulations basiques avec git",
    "text": "3 2. Manipulations basiques avec git\n✍Hand on 1 Cette partie à pour but de vous faire essayer des commandes de bases de git.\n\nCréez dans votre dépôt local un fichier hello_&lt;prenom&gt;.txt qui contient par exemple hello &lt;prenom&gt;\nDans le terminal, tapez la commande git status pour voir si votre fichier s’affiche\nCréez un fichier hello_&lt;prenom&gt;.log qui contient par exemple aaaaa\nTapez git status pour voir si votre fichier s’affiche\n\n💡 Normalement il ne s’affichera pas car si vous ouvrez le fichier .gitignore, vous remarquerez que tous les fichiers *.log sont ignorés par Git.\n\nTapez git add . pour ajouter à la zone de transit (stagging area) tous les fichiers en attente\ngit status pour vérifier que votre fichier hello_&lt;prenom&gt; est prêt à être intégré au prochain commit\nRéalisez un commit git commit -m \"un super message de commit explicite\"\nModifiez votre fichier hello_&lt;prenom&gt;.txt puis faites de nouveau les étapes précédentes (status, add, status, commit)\nRegardez votre historique avec un git log --all --decorate --oneline --graph\nPoussez vos modifications vers le dépôt commun avec un git push\n\nSi quelqu’un a déjà poussé avant vous, vous allez obtenir un message proche de celui-ci\n\nTo https://github.com/ludo2ne/ENSAI-2A-complement-info-TP.git\nMerge branch 'main' of https://github.com/ludo2ne/ENSAI-2A-complement-info-TP\n ! [rejected]        main -&gt; main (fetch first)\nerror: failed to push some refs to 'https://github.com/ludo2ne/ENSAI-2A-complement-info-TP.git'\nhint: Updates were rejected because the remote contains work that you do\nhint: not have locally. This is usually caused by another repository pushing\nhint: to the same ref. You may want to first merge the remote changes (e.g.,\nhint: 'git pull') before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\nDans ce cas, faites dans l’ordre\n\ngit pull : pour mettre à jour votre dépôt local à partir du dépôt distant\ngit push : pour partager vos modifications faites en local vers le dépôt distant\n\nUne fois que tous les membres de l’équipe ont réussi à faire leur push, faites tous un git pull pour avoir chacun des dépôts identiques."
  },
  {
    "objectID": "doc/tp/tp4.html#gérer-un-conflit-avec-git",
    "href": "doc/tp/tp4.html#gérer-un-conflit-avec-git",
    "title": "Git et Création d’une IHM",
    "section": "4 Gérer un conflit avec git",
    "text": "4 Gérer un conflit avec git\n\n4.1 Définition\nUn conflit apparait lorsque 2 versions s’affrontent et que Git ne peut pas savoir laquelle est la bonne.\nExemple : Un dépôt commun contient un seul fichier hello.txt qui contient hello world\n\nAlice et Bob clonent ce dépôt\nEn local Alice modifie le contenu du fichier en hello Alice et fait un add puis commit\nBob fait de même en saisissant hello Bob\nAlice fait un push et met à jour le dépôt commun\nBob fait un push et échoue. Git dit que son dépôt local n’est pas à jour\nBob fait donc un pull pour mettre à jour son dépôt local. C’est à ce moment que le conflit apparait.\n\nBob voulais modifier le contenu du fichier en Hello Bob alors qu’Alice a déjà modifié en Hello Alice\n\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\nHello Bob           (Votre modification - current change)\n=======\nHello Alice         (La modification du dépôt distant - incoming change)\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;\nBob doit maintenant décider quelle version il souhaite garder\nBob choisit Hello Bob, fait un add, commit, push et c’est terminé\n\n\n\n\n4.2 Résolvez vos conflits\n✍Hand on 2 Maintenant vous allez essayer de créer, puis résoudre un conflit !\n\nChoisissez un fichier commun dont vous allez tous modifier le contenu\nModifiez chacun de votre coté (sur vos dépôt locaux) ce fichier\nPoussez votre code\n\nLa première personne à pousser ne devrait pas avoir de conflit, les autres oui. Recommencez la procédure ci-dessus avec un autre fichier pour que tout le monde expérimente la résolution de conflits.\nLorsque vous avez un conflit à gérer :\n\nCorrigez à la main le fichier\n\npar exemple en imposant votre modification\net en supprimant les ======= et les &gt;&gt;&gt;&gt;&gt;&gt;&gt;\n\ngit add . puis git commit -m \"mon super message\" && git push\n\nEn conclusion, avoir des conflits n’est pas grave même si c’est un peu pénible à résoudre. Pour essayer d’éviter les conflits :\n\nfaites des pull et push réguliers\nessayez de travailler en équipe mais sur des fichiers différents"
  },
  {
    "objectID": "doc/tp/tp4.html#bilan-des-trois-premiers-tp",
    "href": "doc/tp/tp4.html#bilan-des-trois-premiers-tp",
    "title": "Git et Création d’une IHM",
    "section": "5 Bilan des trois premiers TP",
    "text": "5 Bilan des trois premiers TP\nSi l’on reprend le modèle en couches présenté en cours, voici ce que l’on a fait depuis le début des TP :\n\n\n5.1 La couche service\nActuellement notre couche service est bien maigre. En effet notre application n’a aucune logique métier. On a bien des objets métiers que l’on persiste mais aucune réelle application derrière. La raison à ce manque provient du fait que cette couche est la partie la plus longue à développer car elle contient la logique métier de l’application.\nEt le but de ces TP n’est pas de vous montrer comment faire une petit application type jeu Pokémon en console. Ils ont pour vocations à vous montrer une architecture de base en couche et vous présenter comment la réaliser. Dans votre projet, il est possible que ce soit la couche service qui vous demande le plus de travail.\n\n\n\n5.2 La couche contrôleur\nLa notion de contrôleur apparait avec le design pattern MVC (Model-View-Controler). Mais c’est un patron de conception beaucoup trop complexe pour faire un simple affichage en console.\nÀ la place vous allez utiliser le patron Model-View-Presenter qui est plus simple car il reprend le principe de couches qui se succèdent.\nIl n’y aura donc pas de couche Controleur mais une couche View qui fera office d’IHM et appelera directement les services nécessaires.\n\n\n\n5.3 La couche view\nLe fonctionnement est le suivant lorsque vous lancez l’application :\n\nvous arrivez sur une vue d’accueil qui propose différents choix\nselon le choix, zéro, un ou plusieurs services sont appelés\npuis vous arrivez vers une nouvelle vue (ou éventuellement resterez sur la même)\n\nExemple :\n\nVous êtes sur la Vue d’accueil et vous sélectionner se connecter\nVous basculez vers la Vue de connexion\n\ndans cette vue, on vous demande de saisir user et password\nune fois la saisie terminée, le Service des utilisateur va être appelé\nce service a une méthode verification_connexion()\n\ncette méthode va appeler la DAO Utilisateur pour vérifier que l’utilisateur et son mot de passe existent bien en base de données\n\n\nsi la vérification est ok, vous basculez vers la Vue Menu utilisateur où va par exemple s’afficher la liste des actions autorisées\n…"
  },
  {
    "objectID": "doc/tp/tp4.html#une-session-pour-les-gouverner-toutes",
    "href": "doc/tp/tp4.html#une-session-pour-les-gouverner-toutes",
    "title": "Git et Création d’une IHM",
    "section": "6 Une session pour les gouverner toutes",
    "text": "6 Une session pour les gouverner toutes\nLà vous pouvez vous dire :\n\nok on va se balader de vues en vues, ça ça va\nmais imaginons l’exemple suivant :\n\non passe par la Vue de connexion et on se connecte avec l’utilisateur Michel\non arrive sur la Vue Menu utilisateur et on se balade dans les différentes vues\nun peu plus tard, on arrive sur la Vue d’ajout de Pokemon, on sélectionne celui qui nous plait et on valide\ncela va aboutir à l’appel d’une méthode DAO du type ajouter_pokemon(utilisateur, pokemon)\nCette méthode a 2 arguments\n\npokemon : ok facile à récupérer, on vient juste avant de le sélectionner\nutilisateur : là c’est moins facile car la dernière fois qu’on avait l’objet utilisateur à portée c’était dans la Vue de connexion\n\n\nEst-ce que une fois connecté, on doit passer l’utilisateur en paramètre de toutes les méthodes que l’on va appeler ?\n\nHeureusement NON, ce serait trop compliqué\n💡 c’est ici que l’objet Session va nous être utile\n\n\nDans notre Session, nous allons pouvoir stocker des objets utiles, par exemple l’utilisateur actif.\nAinsi, une fois connecté, on stocke l’utilisateur en session et on peut se servir de cet objet à tout moment !\nVoici les liens entre notre Session et nos Views :\n\n\n\n\n\nclassDiagram\n\nclass Session{\n    &lt;&lt;singleton&gt;&gt;\n    user_name : str\n    selected_pokemon : AbstractPokemon\n}\n\nclass AbstractView{\n    &lt;&lt;abstract&gt;&gt;\n    +display_info()* None\n    +make_choice()* AbstractView\n}\n\nclass StartView{\n    +display_info() None\n    +make_choice() AbstractView\n}\n\nclass ListPokemonView{\n    +display_info() None\n    +make_choice() AbstractView\n}\n\nclass ListAttackView{\n    +display_info() None\n    +make_choice() AbstractView\n}\n\nSession &lt;..AbstractView: \"use\"\n\nAbstractView &lt;|-- StartView\nAbstractView &lt;|-- ListPokemonView\nAbstractView &lt;|-- ListAttackView\n\n\n\n\n\n\nToute nos Views vont hériter de la classe AbstractView. Cette classe va contenir deux méthodes abstraites :\n\ndisplay_info() : qui va juste déterminer l’affichage en console\nmake_choice() : qui va gérer les choix de l’utilisateur et l’envoyer vers une autre page.\n\nEn plus de cela nous allons gérer tous les attributs utilisés par les View dans un objet Session qui sera un singleton ce qui nous assurera que chaque accès à cet objet retourne la même instance et donc les mêmes valeurs stockées.\nCette architecture vous permet de séparer vos différents menu en fichiers séparés et d’avoir un fonctionnement simple car chaque menu retourne un autre menu simplement.\n⚠️ La création de vos menus peut générer des problèmes de dépendances circulaires. En effet si la page A envoie sur la page B et la page B envoie sur la page A, en fonction de la façon dont vous gérez vos imports vous allez voir un problème de dépendances circulaires. Quand le problème se présentera voici 2 solutions possibles :\n\nremplacer from X import Y en import Y as name\ndéplacer vos imports dans la fonction qui en a besoin"
  },
  {
    "objectID": "doc/tp/tp4.html#inquirerpy",
    "href": "doc/tp/tp4.html#inquirerpy",
    "title": "Git et Création d’une IHM",
    "section": "7 InquirerPy",
    "text": "7 InquirerPy\nPour nous faciliter la gestion de la console nous allons utiliser la bibliothèque python InquirerPy. Elle permet de créer facilement des applications interactives en console. Le projet est bien documenté avec plusieurs exemples de code, faciles à transposer.\n\nLancez le __main__.py et testez un peu l’application\nRegardez les fichiers du package view pour essayer de comprendre comment fonctionnent les vues. Le principe est toujours le même lorsque l’on arrive sur une nouvelle vue :\n\non répond aux questions demandées\nun traitement est éventuellement fait (appel à des services)\non bascule vers une autre vue\n\n\n\n7.1 Mes premières View\n✍Hand on 3\nRépartissez vous le travail entre membre du groupe pour implémenter les Views suivantes :\n\nAffichage Pokémon:\n\nPokemonListView : qui permet de visualiser 30 Pokémons sommairement. Il est possible de sélectionner un pokémon pour aller sur PokemonDetailsView. Vous pouvez permettre un retour arrière sur la StartView si vous le souhaitez.\nPokemonDetailsView : qui affiche les détails du Pokémon sélectionné comme ses statistiques et ses attaques. Renvoie sur la StartView ou PokemonListeView en fonction du choix de l’utilisateur.\n\nAffichage attaque:\n\nAttackListView : qui permet de visualiser 50 attaques sommairement et d’en sélectionner une pour aller sur AttackDetailsView. Vous pouvez permettre un retour arrière sur la StartView.\nAttackDetailsView : qui affiche les détails de l’attaque sélectionnée, comme par exemple ses caractéristiques (name, power, description), mais également quels sont les Pokémons qui peuvent l’apprendre. Renvoie sur la StartView ou AttackListView en fonction du choix de l’utilisateur.\n\nCreatePokemonView : qui permet de créer un Pokémon et le mettre en session. Après validation de l’utilisateur on retourne sur StartView\n\nQuelques astuces :\n\nPokemonService dispose d’une méthode get_pokemon_from_webservice(limit:int, offset:int) pour récupérer des pokémons de la base\nAttackService dispose d’une méthode get_attacks_from_webservice(limit:int, offset:int) pour récupérer des attaques de la base\nde nombreux exemples sont disponibles sur la doc InquirerPy\n\nQuand vous avez terminé une classe, faites un commit, puis poussez sur le dépôt distant.\n\nMerci d’avoir participé et Vive les Pokemons !"
  }
]